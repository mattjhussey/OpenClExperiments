My intention for this experiment is to investigate processing a task using a GPU for mass-multithreading.
The task I will use is related to one I have worked with on a project. It takes a large amount of terrain data in bitmap form and an origin point and then calculates the what areas of terrain can be seen from the origin. The results are stored in another bitmap.
The original task was performed by taking rays from the origin to each pixel of the bitmap, stepping through until the terrain blocked the view. This approach was not particularly fast but worked. The main problem arose as the input bitmap increased and eventually we were unable to load an entire bitmap into memory. Caching of the data was introduced but this did impact the processing times. Caching works well if code is repeatedly requesting a particular value, or if a range of values will be read in a predictable order (a line at a time), but these approaches did not match the ray tracing approach required for the bitmap. On top of this we were restricted by the underlying libraries that read data from files in blocks, so not suitable for our diagonal line approach.
I intend to replicate a basic form of this task using single threading and make it the baseline to improve upon.
I already have an idea for improving the process while using the block approach to caching. The original processed a single ray in a loop until it completed and then moved to the next. I want to take some influence from recursive programming and have each ray setup with enough data to calculate its current position to the end. Instead of calculating until completion, a ray could instead calculate a step and complete, if it finds the answer, else return itself in a new position ready for further calculation when requested to do so. I believe this would be able to improve the caching problem because rather than having to work against the block approach to caching, I can work with it. I can pull out a smaller block of data, provide a set of rays to input to the block and process them through the block. The result will be a set of 0 or more completed rays and 0 or more incomplete rays for further processing.
GPUs are limited by their memory so this approach should work well for them. Also, the slowest part of GPU processing seems to be loading the data into the GPU. Hopefully this approach will limit the number of times data needs to be passed to and from the GPU.  